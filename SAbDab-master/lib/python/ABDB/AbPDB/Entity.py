'''
Created on 15 Mar 2013

@author: dunbar
'''
import io
import sys
from copy import copy
from textwrap import wrap

import Bio.PDB.Entity
from Bio.Data.IUPACData import atom_weights

from ABDB.AbPDB.Visualise import visualise
from ABDB.AbPDB import Select

_ATOM_FORMAT_STRING="%s%5i %-4s%c%3s %c%4i%c   %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s%2s\n"

class Entity(Bio.PDB.Entity.Entity):
    """
    A modified entity object allows for direct writing of coordinates.
    """
            
    def _get_atom_line(self,atom, atom_number=None, charge="  "):
        """
        Modified from Bio.PDB.PDBIO
        """
        hetfield, resseq, icode=atom.parent.get_id()
        resname=atom.parent.get_resname()  
        segid=atom.parent.get_segid()
        if atom_number is None:
            atom_number = atom.serial_number
        chain_id = atom.parent.parent.get_id()
    
        if hetfield!=" ":
            record_type="HETATM"
        else:
            record_type="ATOM  "
        if atom.element:
            element = atom.element.strip().upper()
            if element.capitalize() not in atom_weights:
                raise ValueError("Unrecognised element %r" % atom.element)
            element = element.rjust(2)
        else:
            element = "  "
        name=atom.get_fullname()
        altloc=atom.get_altloc()
        x, y, z=atom.get_coord()
        bfactor=atom.get_bfactor()
        occupancy=atom.get_occupancy()

        args=(record_type, atom_number, name, altloc, resname, chain_id,
            resseq, icode, x, y, z, occupancy, bfactor, segid,
            element, charge)
        return _ATOM_FORMAT_STRING % args
    

    def _get_output_string(self,selection,n):
        """
        Method to get the atom lines of the entity's children.
        
        @param selection: Selector object from AbPDB.Select or derived class from those classes in it.
        
        @param n: An integer value to number the current atom with.
        If this is False the original numbering is used from the pdb file. 
        
        @param remarks: Flag to print out remarks generated by ABDB. Default TRUE
        """
        
        output_string = ""
        
        for child in self.get_list():
            if selection.accept(child):
                if child.level == "A":
                    output_string += self._get_atom_line(child,atom_number=n)
                    if n: n+=1
                else:
                    output_string_add, n = child._get_output_string(selection,n)
                    output_string += output_string_add
        return output_string, n

    def _set_numbering_scheme(self,scheme=None):
        """
        Set the numbering scheme used.
        Derive the numbering scheme from the parent Entity if a scheme is not explicitly given.
        """
        if scheme:
            assert scheme.lower() in [ "c","a","k","w","imgt", "chothia", "martin", "kabat","wolfguy" ], "Unrecognised scheme: %s"%scheme
            self.numbering_scheme = scheme.lower()
        else:
            self.numbering_scheme = self.get_parent().get_numbering_scheme()

    def get_numbering_scheme(self):
        if not hasattr( self, "numbering_scheme" ):
            self._set_numbering_scheme()
        return self.numbering_scheme    

    def _set_region_definition(self,definition=None):
        """
        Set the region definition used. 
        Inherit the region definition from the parent Entity if a scheme is not explicitly given.
        """
        if definition:
            assert definition.lower() in [ "c","n","k","w","imgt","chothia","north","kabat","wolfguy" ], "Unrecognised definition: %s" % definition
            self.region_definition = definition.lower()
        else:
            self.region_definition = self.get_parent().get_region_definition()

    def get_region_definition(self):
        if not hasattr( self, "region_definition" ):
            self._set_region_definition()
        return self.region_definition

    def save(self,output=sys.stdout,renumber=True,selection=False,remarks=True):
        """
        Save the coordinates of the entity
        
        @param output: Where to write coordinates to. 
        Should be an an open file, string or sys.stdout.
        By default the output is written to stdout
        
        @param renumber: Flag whether to renumber the atoms
        Default is to renumber the atoms so that the first is 1 etc.
        Use renumber = False to retain the original atom numbering from the pdb file
        
        @param selection: Provide a selector object to select which children of the entity should be outputted.
        Selection should be a selector object from AbPDB.Select.
        Some basic selector classes are provided in the module. More complex classes can be created by inheriting from these.
        If selection = False (default) all atoms in the entity are output
        
        @param remarks: Flag to print out remarks generated by AbPDB. Default TRUE
        
        NOT RIGOROUSLY TESTED USE WITH CAUTION
        
        Example:
        entity.save("path/to/file/filename.pdb")
        
        residue.save( "residue1.pdb" )
        """

        def ag_chain_and_type(ags):

            if ags:
                chains, types = [],  []
                for ag in ags:
                    if ag.level == "C": # peptide/protein/nucleic acid.
                        chains.append(ag.id); types.append(ag.type)
                    elif ag.level == "R": # hapten / single carb
                        chains.append(ag.parent.id); types.append(ag.type)
                    elif ag.level == "F": # carbs
                        try:
                            chains.append(ag.child_list[0].parent.id); types.append(ag.type) 
                        except IndexError:
                            chains.append("UNKNOWN"); types.append("UNKNOWN")
                    else:
                        chains.append("UNKNOWN"); types.append("UNKNOWN")
                return ";".join(chains), ";".join(types)  
            else:
                return None, None
            
        if renumber:
            n=1
        else:
            n=None
            
        if not selection:
            selection = Select.select_all()
            
        output_string, n_atoms = self._get_output_string(selection,n)
        remark_string=""
        if remarks:
            remark_string=("REMARK   5 %s RENUMBERED STRUCTURE %s GENERATED BY SABDAB\n"%(self.get_numbering_scheme(), str(self.id) )).upper() 
            remark_string+="REMARK   5 ANTIBODY CHAINS ARE RENUMBERED IN THE VARIABLE REGIONS ONLY\n"
            remark_string+="REMARK   5 NON ANTIBODY CHAINS ARE LEFT WITH RESIDUE IDS AS IN PDB\n"
            p=self
            i=0
            while i<6: # only try and go up residue,chain, holder, model, structure
                if hasattr(p, "warnings"):
                    # the entity is the top structure
                    for fab in p.get_fabs():
                        antigen_chain, antigen_type = ag_chain_and_type(fab.antigen)
                        remark_string+= "REMARK   5 PAIRED_HL HCHAIN=%s LCHAIN=%s AGCHAIN=%s AGTYPE=%s\n"%(fab.VH,fab.VL, antigen_chain, antigen_type) 
                    for ab in p.get_abchains():
                        antigen_chain, antigen_type = ag_chain_and_type(ab.antigen)
                        remark_string+= "REMARK   5 SINGLE %sCHAIN=%s AGCHAIN=%s AGTYPE=%s\n"%(ab.chain_type, ab.id, antigen_chain, antigen_type)
                    for warning in str(p.warnings).split("\n"):
                        if warning:
                            remark_string+="\n".join(["REMARK   5 "+l.upper() for l in wrap(warning, width=60 )])+"\n"
                    break
                else:
                    if p:
                        p=p.get_parent()
                        i+=1
                    else:
                        remark_string="";break
                        
        output_string= remark_string.upper()+output_string  
        
        if output is sys.stdout:
            output.write(output_string)
        elif type(output) is str:
            with open(output, 'w') as out:
                out.write(output_string)
        #elif type(output) is file:
        elif isinstance(output, io.IOBase):
            output.write(output_string)
                

    def transform(self, rot, tran):
        """
        Apply rotation and translation to the atomic coordinates.

        Example:
                >>> rotation=rotmat(pi, Vector(1,0,0))
                >>> translation=array((0,0,1), 'f')
                >>> entity.transform(rotation, translation)

        @param rot: A right multiplying rotation matrix
        @type rot: 3x3 Numeric array

        @param tran: the translation vector
        @type tran: size 3 Numeric array
        """

        for o in self.get_list():
            o.transform(rot, tran)



    def copy(self):
        """
        Copy has been played with a bit. For my purposes the version in 1.61 did not work as explicit copying of the child list
        meant that the child objects became referenced to both self and shallow. 
        This may be due to overriding the residue and chain classes so may not be a bug in biopython.

        When copying the child_list in the loop, I use the list to iterate over instead of the dictionary.
        This preserves the ordering of the children.
        """
        shallow = copy(self)
        shallow.child_list = []#copy(self.child_list) # I have removed this explicit copy.
        shallow.child_dict = {}#copy(self.child_dict)
        shallow.xtra = copy(self.xtra)
        shallow.detach_parent()
# Bio.PDB.Entity.Entity
#        for index, child in self.child_dict.items():
#            shallow.detach_child(index)
#            shallow.add(child.copy())
# Order preserving copy
        for child in self.get_list():
            assert child.get_id() in self.child_dict, "child id not in the child_dict keys: this is unexpected and bad :("
            #shallow.detach_child( child.get_id() ) # children are empty anyway
            shallow.add(child.copy())
        return shallow

    def visualise(self):
        visualise(self)
