#! /usr/bin/env python

description='''
A script to prepare an in house structure for submission to SAbDab.
'''

epilogue='''
James Dunbar 2015
'''



# biopython
from Bio.PDB.PDBParser import PDBParser
from Bio.SeqIO.PdbIO import protein_letters_3to1
from Bio import SeqIO
try:
    from Bio.PDB.Polypeptide import to_one_letter_code
except ImportError: # version handling
    from Bio.PDB.Polypeptide import aa1, aa3 # to allow me to return "X" if not found. 
    to_one_letter_code = dict(list(zip(aa3,aa1)))


from textwrap import wrap
from itertools import groupby
import sys
import os
import subprocess
import re

r_value = re.compile("REMARK[ ]+  3[ ]+R[ ]+VALUE[ ]+\(([ A-Z]+)\)[ :]+([0-9\.]+)", re.X )
freer_value = re.compile("REMARK[ ]+  3[ ]+FREE[ ]+R[ ]+VALUE[ ]+:[ ]+([\.0-9]+)", re.X )

def get_seqres(handle):
    '''
    Using own parser as the Biopython one is flakey
    '''
    seqs = {}
    for line in handle: 
        rec_name = line[0:6].strip() 
        if rec_name == 'SEQRES': 
            c = line[11] 
            s = ''.join( [ protein_letters_3to1.get(res, 'X') for res in line[19:].split() ] )
            try:
                seqs[ c ] += s
            except KeyError:
                seqs[c] = s
    return seqs

def check_structure(structure_file, fasta_file, output_dir):
    '''
    '''

    if output_dir:
        prefix = os.path.join( output_dir, '')
        try:
            os.mkdir( prefix )
        except OSError:
            pass
    else:
        prefix = os.path.join(os.path.split( structure_file )[0], '')

    if fasta_file:
        seqres = {}
        try:
            for record in SeqIO.parse(fasta_file, "fasta"):
                name = record.id.strip() 
                assert len(name)==1, 'The fasta identifier must be the chain id only (%s found)'%name
                seqres[name] = str(record.seq)
        except Exception as e:  
            print('Fasta file could not be parsed', repr(e), file=sys.stderr)
            sys.exit(1)
    else:        
        try:
            seqres   = get_seqres(open(structure_file))
        except:
            seqres = {}

    try:
        structure = PDBParser(QUIET=True, PERMISSIVE=True, get_header=True).get_structure( 'structure', structure_file )
    except Exception as e:
        print('Structure could not be parsed', repr(e), file=sys.stderr)
        sys.exit(1)

    struc_sequences = {}
    continuous = {} 
    alignment = {}
    with open(prefix+'%s.flag_message.txt'%os.path.split(structure_file)[1], 'w') as fmessages:
        for model in structure:
            for chain in model:
                struc_sequences[chain.id] = extract_sequence(chain)[1]                                             
                continuous[chain.id] = analyse_continuity( chain )


        # Seqres supersedes struct sequence.
        sequences = {}
        flags = {}
        for extra_chain in set(struc_sequences.keys()) - set( seqres.keys() ): 
            print('A seqres record could not be found for chain %s'%extra_chain, file=fmessages)

        for chain in struc_sequences:
            if not continuous[chain][0]:
                print('Chain %s is not continuous. Suspected missing residue.'%chain, file=fmessages)
            if not struc_sequences[chain]: continue
            sequences[chain] = struc_sequences[chain]
            if seqres.get(chain,''):
                alignment[ chain ] = pairwise_muscle( struc_sequences[chain], seqres[chain] )
                if '-' in alignment[chain][1]:
                    flags[chain] = '|check that seqres/fast file sequence is correct. There are residues in the structure that are not in the seqres record'
                if '-' in alignment[chain][0]:
                    if not continuous[chain][0]:
                        print('Missing residues identified in chain',chain, file=fmessages)
                    else:
                        if '-' in alignment[chain][0].strip('-'):
                            print('Warning. Chain', chain, 'Non-terminal residues identified as missing. However, the chain\'s structure appears continuous.', file=fmessages)
                j=0
                mismatches = []
                for i in range(len(alignment[chain][1])):
                    if alignment[chain][0][j] == '-': continue
                    if alignment[chain][0][j] != alignment[chain][1][i]:
                        mismatches.append(i+1)
                    j+=1
                if mismatches:
                    if chain in flags:
                        flags[chain] += '|check that seqres/fast file sequence is correct. There are different residues in the structure than in the seqres record (seqres positions: %s)'%','.join(map( str, mismatches))
                    else:
                        flags[chain] = '|check that seqres/fast file sequence is correct. There are different residues in the structure than in the seqres record (seqres positions: %s)'%','.join(map( str, mismatches))
                sequences[chain] = seqres[chain]
            elif not continuous[chain][0]:
                flags[chain] = '|check that sequence extracted from structure is correct or (preferably) provide a fasta file for this chain. First missing residue suspected at position %s of this sequence'%continuous[chain][1]
            if chain in flags:
                print('Warning. Chain', chain, flags[chain], file=fmessages)

    with open(prefix+'%s.fasta'%os.path.split(structure_file)[1],'w') as ffile, open( prefix+'%s.details.txt'%os.path.split(structure_file)[1],'w' ) as dfile, open(prefix+'%s.structure.fasta'%os.path.split(structure_file)[1],'w') as sffile :
        write_details( structure_file, structure.header, sequences, dfile )
        write_fasta( list(sequences.items()), flags, ffile )        
        write_fasta( list(struc_sequences.items()), {}, sffile )        
        

def write_details( sfile, header, seqs, out):
    '''
    field	applies_to	value
    method	pdb	X-RAY DIFFRACTION
    resolution	pdb	2.35
    r_free	pdb	0.29
    r_factor	pdb	0.239
    authors	pdb	Ganesan, R., Eigenbrot, C., Shia, S.
    short_header	pdb	HYDROLASE/IMMUNE SYSTEM
    compound	pdb	Crystal structure of HGFA in complex with the allosteric inhibitory antibody Fab40
    date	pdb	09/30/09
    antigen_name	pdb	hepatocyte growth factor activator long chain
    organism	pdb	HOMO SAPIENS
    species	chain_D	homo sapiens
    species	chain_E	homo sapiens
    species	chain_A	homo sapiens
    affinity	pdb	1.6E-010
    delta_g	pdb	-13.36
    affinity_method	pdb	SPR
    temperature	pdb	25 
    '''

    # Re-read file. This is slow - hacking required to keep the header file lines.

    head = open(sfile).read()
    r_free = freer_value.findall(head)
    r = dict(r_value.findall(head))
    if "WORKING SET" in r:
       r = r["WORKING SET"]
    else:
       r = "unknown"
    if r_free:
       r_free = r_free[0]
    else:
       r_free = "unknown"

    name = header.get('journal_reference', '' )
    if not name.strip():
        name = header.get('name','') # We prefer the journal reference but often for in house structures this cannot be found.


    print('field\tapplies_to\tvalue', file=out)
    print('method\tpdb\t%s'%header.get('structure_method', '' ).upper(), file=out)
    print('resolution\tpdb\t%s'%str(header.get('resolution', '' )), file=out)
    print('r_free\tpdb\t%s'%r_free, file=out)
    print('r_factor\tpdb\t%s'%r, file=out)
    print('authors\tpdb\t%s'%str(header.get('author', '' )), file=out)
    print('short_header\tpdb\t%s'%str(header.get('head', name )), file=out)
    print('compound\tpdb\t%s'%str(name), file=out)
    print('date\tpdb\t%s'%str(header.get('deposition_date', '' )), file=out)
    print('antigen_name\tpdb\t', file=out)
    print('organism\tpdb\t', file=out)
    chains_to_species = {}
    for coll in header.get('compound', {}):
        for chain in header['compound'][coll].get('chain','').replace(',','').replace(' ',''):
            chains_to_species[chain] = header.get( 'source', {} ).get( coll, {} ).get('organism_scientific','')
            chains_to_species[chain.upper()] = header.get( 'source', {} ).get( coll, {} ).get('organism_scientific','')
    for chain in seqs:
        print('species\tchain_%s\t%s'%( chain, chains_to_species.get(chain,'') ), file=out)
    print('affinity\tpdb\t', file=out)
    print('delta_g\tpdb\t', file=out)
    print('affinity_method\tpdb\t', file=out)
    print('temperature\tpdb\t', file=out)


def analyse_continuity( chain ):
    '''
    '''
    last = chain.child_list[0]
    i = 1
    for residue in chain.child_list[1:]:
        try:
            if residue.id[0].strip():continue # Don't consider HETATMS. Enforce them to be missed
            if abs(last['C'] - residue['N'] ) > 1.5: # Generous cut-off (average 1.33) for C-N peptide bond.
                return False, i
        except KeyError:
            return False, i
        last = residue
        i+=1
    return True, None


def write_fasta(sequences, flags, f):
    """
    Write a list of sequences to file. 
    
    should be a list of name, sequence tuples
    
    f should be an open file
    """
    for name, sequence in sequences:
        print(">%s"%name + flags.get(name,''), file=f)
        print('\n'.join(['\n'.join(wrap(block, width=80)) for block in sequence.splitlines()]), file=f)


def extract_sequence(chain,selection=False,return_warnings=False, ignore_hets=False,backbone=False):
    """
    Get the amino acid sequence of the chain.
    @change:    Residues containing HETATOMs are skipped -->  Residues containing HETATOMs are checked as an amino acid.
    
    Residues containing HETATOMs are checked  to be amino acids and the single letter returned.
    
    This works provided the residues in the chain are in the correct order.
    
    @param selection: a selection object to select certain residues
    @param return_warnings: Flag to return a list of warnings or not
    @param backbone: Flag whether to only show residues with a complete backbone (in the structure) or not.
    @return: The sequence in a resid:aa tuple list and the sequence as a string.
    
    """
    sequence_list = []
    warnings=[]
    for residue in chain.get_list():
        if residue.id[0] != " ": # skip HETATOMs - this is not necesserily a good idea, flag to the user that is has been done.
#            if residue.get_resname() not in to_one_letter_code: # Check that the residue can be converted into a single letter. 
#                continue
#            if residue.get_resname() in to_one_letter_code: # Check that the residue can be converted into a single letter. 
#                pass 
            if residue.get_resname() in to_one_letter_code:
                if ignore_hets:
                    if return_warnings:
                        warnings.append("Warning: HETATM residue %s at position %s (PDB numbering) found in chain %s. Not including it in structure's sequence."%(residue.get_resname(), str(residue.id[1])+residue.id[2].strip(), residue.parent.id ))
                    else:
                        print("Warning: HETATM residue %s position %s (PDB numbering) found in chain %s. Not including it in structure's sequence."%(residue.get_resname(), str(residue.id[1])+residue.id[2].strip(), residue.parent.id ), file=sys.stderr)
                    continue
            else:
                continue
        if selection:
            if not selection.accept(residue): continue

        atoms_of_residue = list(residue.child_dict.keys())
        backboneCondition = ('N' in atoms_of_residue and 'C' in atoms_of_residue and 'CA' in atoms_of_residue and 'O' in atoms_of_residue) # Boolean to hold if residue has a full backbone

		# CASE 1: backbone = True, and residue has a full backbone; convert a.a into single letter
        if backbone and backboneCondition:
            sequence_list.append( (residue.id, to_one_letter_code.get(residue.get_resname(), 'X') ) )
        # CASE 2: backbone = True, but residue does not have a full backbone; use a gap in sequence annotation
        elif backbone and not backboneCondition:
            sequence_list.append( (residue.id, '-' ) )
        # CASE 0 (default): don't care about backbone, just write it to sequence if it's found in structure.
        elif not backbone:
            sequence_list.append( (residue.id, to_one_letter_code.get(residue.get_resname(), 'X') ) ) # i am 

    sequence_str = "".join([r[1] for r in sequence_list])
    if not return_warnings:
        return sequence_list, sequence_str
    else:
        return sequence_list, sequence_str, warnings    



def pairwise_muscle(seq1, seq2,exact=True):
    """
    Interface with pairwise muscle between two sequences that should be identical.
 
    Try an easy alignment first by checking that one is in the other.
 
    Then if this fails (gaps) use muscle to align the sequences - this should work for seqres and structure sequences with missing atoms.
    
    Use muscle to align.
    
    if exact is True
    The gap open penalty is slightly larger than gap extend to break degeneracy between:
    
    1)garbleabcdefg----
      -a-----bcdefg----
     
    and
     
    2)garbleabcdefg----
      ------abcdefg----
    But they are penalties will still make mismatch very unlikely.
    else
    default muscle
    """

    if not muscle:
        raise Exception("Muscle is not installed or ABDB does not know where to find it - run setup script.")    
    
    try_easy  = easy_alignment(seq1, seq2)
    if try_easy:
        return try_easy[0],try_easy[1]
    
    if exact:
        p = subprocess.Popen( ['muscle','-gapopen', '-1.001','-gapextend', '-1'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE )
    else:
        p = subprocess.Popen( [muscle], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE )
    output = p.communicate('>seq1\n%s\n>seq2\n%s'%(seq1,seq2))
    # check what you have been given.
    result = output[0].split(">")
    # expect it to have 2 entries
    if len(result) == 3:
        seq1_ali = result[1]
        seq2_ali = result[2]
        return "".join( seq1_ali.split("\n")[1:]), "".join( seq2_ali.split("\n")[1:])
    else:
        print("Problem parsing output from muscle: %s"%output[0], file=sys.stderr)
        
def muscle(sequences, gapopen=None, gapextend=None):
    """
    Use muscle to align sequences.
    
    @param sequences: dictionary of sequences.
    
    @param gapopen: The penalty for opening a gap. 
    @param gapextend: The penalty for extending a gap
    
    @return: A dictionary of aligned sequences.
    """
    if not muscle:
        raise Exception("Muscle could not be found in the path.")    
    if not sequences:
        return {}
    extra_args=[]    
    if gapopen:
        extra_args+= [ "-gapopen", str(float(gapopen)) ]    
    if gapextend:
        extra_args+= [ "-gapextend", str(float(gapextend)) ]
    p = subprocess.Popen( [muscle_path]+extra_args  , stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE )        
    output = p.communicate("\n".join([ ">"+name+"\n"+sequences[name] for name in sequences ]))
    try:
        return dict( (e.split("\n")[0], "".join(e.split("\n")[1:])) for e in  map(str.strip, output[0].split(">"))[1:] )
    except:
        print("Problem parsing output from muscle: %s"%output[0], file=sys.stderr)
        return None

def which(name, flags=os.X_OK):
    """
    Search PATH for executable files with the given name.
   
    On newer versions of MS-Windows, the PATHEXT environment variable will be
    set to the list of file extensions for files considered executable. This
    will normally include things like ".EXE". This fuction will also find files
    with the given name ending with any of these extensions.

    On MS-Windows the only flag that has any meaning is os.F_OK. Any other
    flags will be ignored.
   
    @type name: C{str}
    @param name: The name for which to search.
   
    @type flags: C{int}
    @param flags: Arguments to L{os.access}.
   
    @rtype: C{list}
    @param: A list of the unique full paths to files found, in the
    order in which they were found.
    """
    result = []
    exts = [_f for _f in os.environ.get('PATHEXT', '').split(os.pathsep) if _f]
    path = os.environ.get('PATH', None)
    if path is None:
        return []
    for p in os.environ.get('PATH', '').split(os.pathsep):
        p = os.path.join(p, name)
        if os.access(p, flags):
            result.append(p)
        for e in exts:
            pext = p + e
            if os.access(pext, flags):
                result.append(pext)
    return uniq(result)

def uniq(seq, idfun=None):
    """
    A function to uniquify a sequence.
    With thanks to http://www.peterbe.com

    @param seq: A sequence to uniquify
    @param idfun: An optional function to use as a key. Like the "key" kwarg in C{sorted}. 
    
    @return: The sequence.
    """
    # order preserving
    if idfun is None:
        def idfun(x): return x
    seen = {}
    result = []
    for item in seq:
        marker = idfun(item)
        if marker in seen: continue
        seen[marker] = 1
        result.append(item)
    return result


    
def easy_alignment(seq1, seq2):
    """
    Function to align two sequences by checking if one is in the other.
    This function will conserve gaps.
    """
    assert type(seq1) is str and type(seq2) is str, "Sequences must be strings for easy_alignment" 
    if seq1 in seq2:
        start = seq2.index(seq1)
        seq1_ali = "-"*start + seq1 + "-"*(len(seq2) - start - len(seq1) )
        return seq1_ali, seq2
    elif seq2 in seq1:
        start = seq1.index(seq2)
        seq2_ali = "-"*start + seq2 + "-"*(len(seq1) - start - len(seq2) )
        return seq1, seq2_ali
    else:
        # Can't align them # I return just one value here. 
        return False        

if __name__ == '__main__' :
    import argparse
    parser = argparse.ArgumentParser(prog="prepare_submission", description=description, epilog=epilogue,formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument( '--pdbfile','-p', type=str, help="A PDB file to be submitted", dest="pdbfile")
    parser.add_argument( '--fastafile','-f', type=str, default=None,  help="A fasta file containing the amino acid sequences of the chains.", dest="fastafile")    
    parser.add_argument( '--output_dir','-o', type=str, default=None, help="Output directory. If none is given then the output is given in the same directory as the input pdb directory", dest="output_dir")    
    if len(sys.argv) < 2:
        parser.print_help()
        sys.exit(0)
    args = parser.parse_args()
    check_structure( args.pdbfile, args.fastafile, args.output_dir )


